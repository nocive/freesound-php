<?php

/***********************************************************
 *
 * Freesound API client bundle file
 * You should NOT edit this file!
 * This file was automatically generated by PHP.
 *
 * Generated at: Sun, 18 Mar 2012 00:26:00 +0000
 *
 ***********************************************************/

/*************************************************************************************************
 *
 * Freesound (http://freesound.org) API client library
 *
 * PHP library for interacting with the Freesound.org API
 *
 * PHP >= 5.3
 *
 * @category API Client
 * @package  Freesound
 * @author   Jose' Pedro Saraiva <nocive _ gmail _ com>
 * @license  GPL-3.0 http://www.opensource.org/licenses/GPL-3.0
 * @version  0.1
 * @see      http://www.freesound.org/docs/api/overview.html
 * @see      http://www.freesound.org/docs/api/resources.html#resources
 * @see      https://github.com/ffont/freesound-javascript/blob/master/freesoundLib.js
 *
 *************************************************************************************************/

if (! class_exists( 'Freesound_Bootstrap' )) {
	require_once( __DIR__ . '/Bootstrap/Bootstrap.php' );
}

/**
 * Main class
 *
 * @package Freesound
 */
class Freesound extends Freesound_Base
{
	public $interfaces;


	public function __construct( $apiKey = null, $config = null )
	{
		$this->_config = $config !== null ? $config : new Freesound_Config();
		if ($apiKey !== null) {
			$this->_config->Set( self::CFG_API_KEY, $apiKey );
		}

		$this->interfaces = new StdClass();
		foreach( Freesound_API_Base::$interfaceNames as $iname ) {
			$class = 'Freesound_API_' . ucfirst( strtolower( $iname ) );
			$this->interfaces->{$iname} = new $class( $apiKey, $this->_config );
		}
	}


	public function Config()
	{
		return call_user_func_array( array( $this->_config, 'Set' ), func_get_args() );
	}


	public function __call( $method, $args )
	{
		foreach( get_object_vars( $this->interfaces ) as $var => $value ) {
			if (strtolower( $method ) === $var) {
				if (count( $args ) === 1) {
					$this->interfaces->{$var}->id = $args[0];
				}
				return $this->interfaces->{$var};
			}

			$realMethod = substr( $method, strlen( $var ) );
			if (stripos( $method, $var ) === 0 && method_exists( $this->interfaces->{$var}, $realMethod )) {
				return call_user_func_array( array( $this->interfaces->{$var}, $realMethod ), $args );
			}
		}

		throw new Exception( "Invalid method: $method" );
	}
}




/**
 * Base class
 *
 * @package    Freesound
 */
abstract class Freesound_Base
{
	protected $_config;

	const VERSION = '0.1';
	const WEBSITE = 'https://github.com/nocive/Freesound';
	const URL_BASE = 'http://www.freesound.org/api/';

	const CFG_API_KEY = 'api_key';
	const CFG_DEBUG = 'debug';
	const CFG_FETCH_CONNECT_TIMEOUT = 'fetch_connect_timeout';
	const CFG_FETCH_TIMEOUT = 'fetch_timeout';
	const CFG_FETCH_USER_AGENT = 'fetch_user_agent';
	const CFG_JSON_DECODE_ASSOC = 'json_decode_assoc';
}




/**
 * Bootstrap class
 *
 * @package    Freesound
 * @subpackage Freesound_Bootstrap
 */
class Freesound_Bootstrap
{
	public static $classmap = array(
		'Freesound' => 'Freesound',
		'Freesound_Base' => 'Base/Base',
		'Freesound_Bootstrap' => 'Bootstrap/Bootstrap',
		'Freesound_Config' => 'Config/Config',
		'Freesound_Utils' => 'Utils/Utils',
		'Freesound_API_Base' => 'API/Base',
		'Freesound_API_Pack' => 'API/Pack',
		'Freesound_API_Sound' => 'API/Sound',
		'Freesound_API_User' => 'API/User',
		'Freesound_Test' => 'Test/Test',
		'Freesound_CommunicationException' => 'Exception/Exception',
		'Freesound_MalformedResponseException' => 'Exception/Exception',
		'Freesound_APIErrorException' => 'Exception/Exception'
	);

	const CLASS_EXTENSION = '.php';


	public static function Autoload( $class )
	{
		if (isset( self::$classmap[$class] )) {
			$classFile = __DIR__ . '/../' . self::$classmap[$class] . self::CLASS_EXTENSION;
			include_once( $classFile );
		}
	}


	public static function AutoloadRegister()
	{
		spl_autoload_register( __CLASS__ . '::Autoload' );
	}
}

if (! class_exists( 'Freesound' )) {
	Freesound_Bootstrap::AutoloadRegister();
}




/**
 * Config class
 *
 * @package    Freesound
 * @subpackage Freesound_Config
 */
class Freesound_Config extends Freesound_Base
{
	protected $_config = array();
	
	protected static $_defaults = array(
		self::CFG_API_KEY => '',
		self::CFG_DEBUG => 0,
		self::CFG_FETCH_CONNECT_TIMEOUT => 30,
		self::CFG_FETCH_TIMEOUT => 30,
		self::CFG_FETCH_USER_AGENT => 'Freesound API PHP client v%VERSION% (%WEBSITE%)',
		self::CFG_JSON_DECODE_ASSOC => false
	);


	public function __construct( $cfg = null )
	{
		$cfg = $cfg !== null ? array_merge( self::$_defaults, $cfg ) : self::$_defaults;
		$this->Set( $cfg );
	}


	public function Get()
	{
		if (func_num_args() === 0) {
			return $this->_config;
		}

		$args = func_get_args();
		if (func_num_args() === 1) {
			if (is_array( $args[0] )) {
				$args = $args[0];
			} else {
				return $this->_config[$args[0]];
			}
		}

		$return = array();
		foreach ( $args as $a ) {
			$return[$a] = $this->_config[$a];
		}
		return $return;
	}


	public function Set()
	{
		$args = func_get_args();
		$argc = func_num_args();

		if ($argc !== 1 && $argc !== 2) {
			throw new InvalidArgumentException( 'Wrong number of parameters' );
		}

		if ($argc === 1 && is_array( $args[0] )) {
			$vars = array_combine( array_keys( $args[0] ), array_values( $args[0] ) );
		} elseif ($argc === 2) {
			$vars = array_combine( array( $args[0] ), array( $args[1] ) );
		}

		foreach ( $vars as $var => $value ) {
			if (array_key_exists( $var, self::$_defaults )) {
				if ($var === self::CFG_FETCH_USER_AGENT) {
					$value = str_replace( array( '%VERSION%', '%WEBSITE%' ), array( self::VERSION, self::WEBSITE ), $value );
				}
				$this->_config[$var] = $value;
			}
		}
	}


	public function Reset()
	{
		$this->Set( self::$_defaults );
	}	
}




/**
 * Utilities class
 *
 * @package    Freesound
 * @subpackage Freesound_Utils
 */
class Freesound_Utils
{
	public static function BundleBuild( $file, $overwrite = false )
	{
		if (! $overwrite && is_file( $file )) {
			throw new Exception( "File '$file' already exists, please remove it before trying to build a new bundle" );
		}

		$basepath = __DIR__ . '/../';
		$classpaths = array_unique( array_values( Freesound_Bootstrap::$classmap ) );

		$content = "\n\n";
		$content .= "/***********************************************************\n";
		$content .= " *\n";
		$content .= " * Freesound API client bundle file\n";
		$content .= " * You should NOT edit this file!\n";
		$content .= " * This file was automatically generated by PHP.\n";
		$content .= " *\n";
		$content .= " * Generated at: " . date( 'r' ) . "\n";
		$content .= " *\n";
		$content .= " ***********************************************************/\n\n";

		foreach( $classpaths as $path ) {
			$f = $basepath . $path . Freesound_Bootstrap::CLASS_EXTENSION;
			if (false === ($c = @file_get_contents( $f ))) {
				throw new Exception( "Could not open file '$f'" );
			}
			// remove php tags
			$c = preg_replace( array( '#<\?(?:php)?\s*#s', '#\?\>(?=([\s\n]+)?$(?!\n))#s' ), null, $c );
			$content .= "$c\n\n";
		}

		$content .= "?>";

		return @file_put_contents( $file, $content ) !== false;
	}
}




/**
 * Base class for API classes
 *
 * @package    Freesound
 * @subpackage Freesound_API
 */
abstract class Freesound_API_Base extends Freesound_Base
{
	public $id;

	public static $interfaceNames = array(
		'sound',
		'user',
		'pack'
	);

	const PARAM_API_KEY = 'api_key';
	const DEFAULT_CONNECT_TIMEOUT = 20;
	const DEFAULT_TIMEOUT = 30;

	public function __construct( $apiKey = null, $config = null )
	{
		$this->_config = $config !== null ? $config : new Freesound_Config();
		if ($apiKey !== null) {
			$this->_config->Set( self::CFG_API_KEY, $apiKey );
		}
	}


	public function __destruct()
	{
	}


	protected function _id( $id )
	{
		if ($id === null) {
			$id = $this->id;
			$this->id = null;
		}
		return $id;
	}


	protected function _RequestUrl( $method, $args = null, $extraArgs = null )
	{
		$apiKey = $this->_config->Get( self::CFG_API_KEY );
		if (empty( $apiKey )) {
			throw new Exception( 'API key not set or empty' );
		}

		$constUrl = 'static::URL_' . strtoupper( $method );
		if (! defined( $constUrl )) {
			throw new InvalidArgumentException( "No such API method '$method'" );
		}

		$url = vsprintf( preg_replace( '/<[\w_]+>/', '%s', constant( $constUrl ) ), $args );
		$extraArgs = is_array( $extraArgs ) ? $extraArgs: array();
		$queryString = http_build_query( array_merge( $extraArgs, array( self::PARAM_API_KEY => $apiKey ) ) );

		return rtrim( self::URL_BASE, '/' ) . '/' . ltrim( $url, '/' ) . '?' . $queryString;
	}


	protected function _Request( $method, $args = null, $extraArgs = null )
	{
		$start = microtime( true );

		$cfg = $this->_config->Get(); // cache it
		$url = $this->_RequestUrl( $method, $args, $extraArgs );

		$curlopts = array(
			CURLOPT_URL => $url,
			CURLOPT_RETURNTRANSFER => 1,
			CURLOPT_VERBOSE => $cfg[self::CFG_DEBUG] > 1,
			CURLOPT_CONNECTTIMEOUT => isset( $cfg[self::CFG_FETCH_CONNECT_TIMEOUT] ) ? $cfg[self::CFG_FETCH_CONNECT_TIMEOUT] : static::DEFAULT_CONNECT_TIMEOUT,
			CURLOPT_TIMEOUT => isset( $cfg[self::CFG_FETCH_TIMEOUT] ) ? $cfg[self::CFG_FETCH_TIMEOUT] : static::DEFAULT_TIMEOUT,
			CURLOPT_USERAGENT => isset( $cfg[self::CFG_FETCH_USER_AGENT] ) ? $cfg[self::CFG_FETCH_USER_AGENT] : ini_get( 'user_agent' )
		);

		if ($cfg[self::CFG_DEBUG]) {
			echo "Requesting: $url... ";
		}

		$c = curl_init();
		curl_setopt_array( $c, $curlopts );
		$response = curl_exec( $c );
		$httpCode = curl_getinfo( $c, CURLINFO_HTTP_CODE );
		curl_close( $c );

		if ($cfg[self::CFG_DEBUG]) {
			echo "took: " . round( microtime( true ) - $start, 2 ) . "s\n";
		}

		if ($response === false) {
			throw new Freesound_CommunicationException( "Error contacting the freesound API. HTTP Code: $httpCode" );
		}

		$response = json_decode( $response, $cfg[self::CFG_JSON_DECODE_ASSOC] );
		if ($response === false) {
			throw new Freesound_MalformedResponseException( 'Error parsing the freesound API response' );
		}

		if ($httpCode !== 200) {
			throw new Freesound_APIErrorException( "API error, response: " . print_r( $response, true ) );
		}

		return $response;
	}
}




/**
 * Pack class
 *
 * @package    Freesound
 * @subpackage Freesound_API
 */
class Freesound_API_Pack extends Freesound_API_Base
{
	const URL_PACK = '/packs/<pack_id>/';
	const URL_PACK_SOUNDS = '/packs/<pack_id>/sounds/';


	public function Get( $id = null )
	{
		$id = $this->_id( $id );
		return $this->_Request( 'pack', $id );
	}


	public function GetSounds( $id = null )
	{
		$id = $this->_id( $id );
		return $this->_Request( 'pack_sounds', $id );
	}
}




/**
 * Sound class
 *
 * @package    Freesound
 * @subpackage Freesound_API
 */
class Freesound_API_Sound extends Freesound_API_Base
{
	const URL_SOUND = '/sounds/<sound_id>/';
	const URL_SOUND_ANALYSIS = '/sounds/<sound_id>/analysis/<filter>/';
	const URL_SOUND_ANALYSIS_NO_FILTER = '/sounds/<sound_id>/analysis/';
	const URL_SOUND_GEOTAG = '/sounds/geotag/';
	const URL_SOUND_SIMILAR = '/sounds/<sound_id>/similar/';
	const URL_SOUND_SEARCH = '/sounds/search/';


	public function Get( $id = null )
	{
		$id = $this->_id( $id );
		return $this->_Request( 'sound', $id );
	}


	public function GetAnalysis( $id = null, $filter = null, $all = false )
	{
		$id = $this->_id( $id );

		if (empty( $filter )) {
			$filter = false;
			$method = 'sound_analysis_no_filter';
		} else {
			$method = 'sound_analysis';
			if (is_array( $filter )) {
				$filter = implode( '/', $filter );
			}
		}

		return $this->_Request( $method, array( $id, $filter ), array(
			'all' => $all
		));
	}


	public function GetSimilar( $id = null, $num = null, $preset = null, $fields = null )
	{
		$id = $this->_id( $id );

		return $this->_Request( 'sound_similar', $id, array(
			'num_results' => $num,
			'preset' => $preset,
			'fields' => $fields
		));
	}


	public function Search( $query, $page = null, $filter = null, $sort = null, $fields = null )
	{
		return $this->_Request( 'sound_search', null, array(
			'q' => $query,
			'p' => $page,
			'f' => $filter,
			's' => $sort,
			'fields' => $fields
		));
	}


	public function SearchGeo( $minLat = null, $maxLat = null, $minLon = null, $maxLon = null, $page = null, $fields = null )
	{
		return $this->_Request( 'sound_geotag', null, array(
			'min_lat' => $minLat,
			'max_lat' => $maxLat,
			'min_lon' => $minLon,
			'max_lon' => $maxLon,
			'p' => $page,
			'fields' => $fields
		));
	}


}




/**
 * User class
 *
 * @package    Freesound
 * @subpackage Freesound_API
 */
class Freesound_API_User extends Freesound_API_Base
{
	const URL_USER = '/people/<user_name>/';
	const URL_USER_SOUNDS = '/people/<user_name>/sounds/';
	const URL_USER_PACKS = '/people/<user_name>/packs/';


	public function Get( $username = null )
	{
		$username = $this->_id( $username );
		return $this->_Request( 'user', $username );
	}


	public function GetSounds( $username = null )
	{
		$username = $this->_id( $username );
		return $this->_Request( 'user_sounds', $username );
	}


	public function GetPacks( $username = null )
	{
		$username = $this->_id( $username );
		return $this->_Request( 'user_packs', $username );
	}
}




class Freesound_Test
{
	protected $_params;
	protected $_class;

	public function __construct( $class, $params = null )
	{
		if (! is_object( $class )) {
			throw new InvalidArgumentException( '$class must be a valid object' );
		}

		$this->_params = $params;
		$this->_class = $class;

	}


	public function RunAll()
	{
		$r = array();
		foreach( get_object_vars( $this->_class->interfaces ) as $var => $value ) {
			foreach( get_class_methods( $value ) as $method ) {
				if (substr( $method, 0, 1 ) !== '_' ) {
					$classmethod = ucfirst( $var ) . $method;
					$args = ! empty( $this->_params[$classmethod] ) ? $this->_params[$classmethod] : array();
					$r[$classmethod] = call_user_func_array( array( $value, $method ), $args );
				}
			}
		}
		return $r;
	}


	// TODO implement __call for unit tests
}




class Freesound_Exception extends Exception {}
class Freesound_CommunicationException extends Freesound_Exception {}
class Freesound_MalformedResponseException extends Freesound_Exception {}
class Freesound_APIErrorException extends Freesound_Exception {}




?>